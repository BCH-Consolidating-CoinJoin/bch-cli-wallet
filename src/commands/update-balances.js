/*
  oclif command to update the balances stored in the wallet.json file.
*/

"use strict"

const fs = require("fs")
const BB = require("bitbox-sdk/lib/bitbox-sdk").default

const util = require("util")
util.inspect.defaultOptions = { depth: 2 }

const { Command, flags } = require("@oclif/command")

class UpdateBalances extends Command {
  async run() {
    try {
      const { flags } = this.parse(UpdateBalances)

      // Exit if wallet not specified.
      const name = flags.name
      if (!name || name === "")
        throw new Error(`You must specify a wallet with the -n flag.`)

      const walletInfo = this.openWallet(name)

      // Determine if this is a testnet wallet or a mainnet wallet.
      if (walletInfo.network === "testnet")
        var BITBOX = new BB({ restURL: "https://trest.bitcoin.com/v1/" })
      else var BITBOX = new BB({ restURL: "https://rest.bitcoin.com/v1/" })

      await this.updateBalances(walletInfo, BITBOX)
    } catch (err) {
      if (err.message) console.log(err.message)
      else console.log(`Error in UpdateBalances.run: `, err)
    }
  }

  async updateBalances(walletInfo, BITBOX) {
    console.log(`Existing balance: ${walletInfo.balance} BCH`)

    // Query data on each address that has been generated by the wallet.
    const addressData = await this.getAddressData(walletInfo, BITBOX)
    console.log(`addressData: ${util.inspect(addressData)}`)

    // Update hasBalance array with non-zero balances.

    // Sum all the balances in hasBalance to calculate total balance.
  }

  // Retrieves data (objects) on all addresses in an HD wallet and returns an
  // array of these objects.
  async getAddressData(walletInfo, BITBOX) {
    const numberOfAddresses = walletInfo.nextAddress - 1

    const balances = []
    for (var i = 0; i < numberOfAddresses; i++) {
      const thisAddress = this.generateAddress(walletInfo, i, BITBOX)

      // get BCH balance
      const balance = await BITBOX.Address.details([thisAddress])
      balances.push(balance)
    }

    return balances
  }

  // Generates an HD address for the given index and wallet info.
  generateAddress(walletInfo, index, BITBOX) {
    // root seed buffer
    const rootSeed = BITBOX.Mnemonic.toSeed(walletInfo.mnemonic)

    // master HDNode
    if (walletInfo.network === "testnet")
      var masterHDNode = BITBOX.HDNode.fromSeed(rootSeed, "testnet")
    else var masterHDNode = BITBOX.HDNode.fromSeed(rootSeed)

    // HDNode of BIP44 account
    const account = BITBOX.HDNode.derivePath(masterHDNode, "m/44'/145'/0'")

    // derive an external change address HDNode
    const change = BITBOX.HDNode.derivePath(
      account,
      `0/${walletInfo.nextAddress}`
    )

    // get the cash address
    const newAddress = BITBOX.HDNode.toCashAddress(change)
    //const legacy = BITBOX.HDNode.toLegacyAddress(change)

    return newAddress
  }

  // Open a wallet by file name.
  openWallet(name) {
    try {
      const walletInfo = require(`../../wallets/${name}.json`)
      return walletInfo
    } catch (err) {
      throw new Error(`Could not open ${name}.json`)
    }
  }

  // Wrap the file save stuff in a Promise.
  saveWallet(name, walletData) {
    return new Promise((resolve, reject) => {
      fs.writeFile(
        `./wallets/${name}.json`,
        JSON.stringify(walletData, null, 2),
        function(err) {
          if (err) return reject(console.error(err))

          //console.log(`${name}.json written successfully.`)
          return resolve()
        }
      )
    })
  }
}

UpdateBalances.description = `Poll the network and update the balances of the wallet.`

UpdateBalances.flags = {
  name: flags.string({ char: "n", description: "Name of wallet" })
}

module.exports = UpdateBalances
